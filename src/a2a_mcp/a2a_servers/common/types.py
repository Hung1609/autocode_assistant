# This file is used to:
# model entities(các thực thể) like Task, Message, Artifact, Request/Response RPC, Error to serve an interactive system between users and AI agents via JSON-RPC 2.0 protocol

from typing import Union, Any
from pydantic import BaseModel, Field, TypeAdapter
from typing import Literal, List, Annotated, Optional
from datetime import datetime
from pydantic import model_validator, ConfigDict, field_serializer
from uuid import uuid4
from enum import Enum
from typing_extensions import Self

class TaskState(str, Enum): # -> all the state of a task -> used in TaskStatus
    SUBMITTED = "submitted" # Task has been received
    WORKING = "working" # Task is in progress
    INPUT_REQUIRED = "input-required" # Agent is waiting for more input
    COMPLETED = "completed" # Task is done
    CANCELED = "canceled" # Task was canceled by user or system
    FAILED = "failed" # Something went wrong
    UNKNOWN = "unknown" # Fallback for undefined or unrecognized states

# Part: The atomic content unit within Messages or Artifacts.
# Parts can be of different types:
# TextPart: For plain text content
# FilePart: For file data (either inline or referenced via URI)
# DataPart: For structured JSON data (commonly used for forms or structured responses)

class TextPart(BaseModel):
    type: Literal["text"] = "text" # mark the type as "text"
    text: str # content
    metadata: dict[str, Any] | None = None

class FileContent(BaseModel):
    name: str | None = None
    mimeType: str | None = None
    bytes: str | None = None
    uri: str | None = None

    @model_validator(mode="after") # Đảm bảo chỉ một trong bytes hoặc uri được cung cấp.
    def check_content(self) -> Self:
        if not (self.bytes or self.uri):
            raise ValueError("Either 'bytes' or 'uri' must be present in the file data")
        if self.bytes and self.uri:
            raise ValueError("Only one of 'bytes' or 'uri' can be present in the file data")
        return self
    
class FilePart(BaseModel):
    type: Literal["file"] = "file"
    file: FileContent
    metadata: dict[str, Any] | None = None

class DataPart(BaseModel):
    type: Literal["data"] = "data"
    data: dict[str, Any]
    metadata: dict[str, Any] | None = None

Part = Annotated[Union[TextPart, FilePart, DataPart], Field(discriminator="type")]

# Message: The basic unit of communication between clients and agents.
# Messages contain a role (either "user" or "agent") and are composed of one or more Parts, forming the conversation thread.
class Message(BaseModel): # cấu trúc thông diệp trong giao tiếp giữa user và agent -> dùng trong Task.history để lưu lịch sử giao tiếp và TaskStatus.message để gửi thông báo trạng thái.
    role: Literal["user", "agent"]
    parts: List[Part]
    metadata: dict[str, Any] | None = None

class TaskStatus(BaseModel): # trạng thái của 1 task
    status: TaskState
    message: Message | None = None
    timestamp: datetime = Field(default_factory=datetime.now) # Field trong Pydantic không nhận tham số Default_factory viết hoa. --> sửa thành viết thường

    @field_serializer("timestamp") # Chuyển datetime thành chuỗi ISO khi xuất JSON.
    def serialize_dt(self, dt:datetime, _info):
        return dt.isoformat()

# Artifact: Represents any output generated by an agent during task execution.
# This could include generated files, structured data, or other resources.
# Like Messages, Artifacts are composed of Parts.
# Dùng trong TaskArtifactUpdateEvent để thông báo cập nhật hiện vật.
class Artifact(BaseModel):
    name: str | None = None
    description: str | None = None
    parts: List[Part]
    metadata: dict[str, Any] | None = None
    index: int = 0
    append: bool | None = None
    lastChunk: bool | None = None

# Task: The primary unit of work in A2A.
# When a client initiates a task, it creates a unique conversation thread that can progress through various states: submitted, working, input-required, completed, failed, or canceled.
# Each task maintains its own context and history.
# Là cấu trúc chính để theo dõi và quản lý tác vụ.
# Trả về trong GetTaskResponse hoặc SendTaskResponse.
class Task(BaseModel):
    id: str
    sessionId: str | None = None
    status: TaskStatus
    artifacts: List[Artifact] | None = None
    history: List[Message] | None = None
    metadata: dict[str, Any] | None = None

# Event model
# Dùng trong SendTaskStreamingResponse để gửi cập nhật thời gian thực.
class TaskStatusUpdateEvent(BaseModel):
    id: str
    status: TaskStatus
    final: bool = False
    metadata: dict[str, Any] | None = None

class TaskArtifactUpdateEvent(BaseModel):
    id: str
    artifact: Artifact
    metadata: dict[str, Any] | None = None

# authentication model
# Dùng trong TaskSendParams và TaskPushNotificationConfig để gửi thông báo khi tác vụ thay đổi.
class AuthenticationInfo(BaseModel):
    model_config = ConfigDict(extra="allow") # cho phép trường bổ sung
    schemas: List[str]
    credentials: str | None = None

class PushNotificationConfig(BaseModel):
    url: str
    token: str | None = None
    authentication: AuthenticationInfo | None = None

# Params model
# Các class dùng để định nghĩa tham số cho các yêu cầu RPC.
class TaskIdParams(BaseModel):
    id: str
    metadata: dict[str, Any] | None = None

class TaskQueryParams(TaskIdParams):
    historyLength: int | None = None

class TaskSendParams(BaseModel):
    id: str
    sessionId: str = Field(default_factory=lambda: uuid4().hex)
    message: Message
    acceptedOutputModes: Optional[List[str]] = None
    pushNotification: PushNotificationConfig | None = None
    historyLength: int | None = None
    metadata: dict[str, Any] | None = None

class TaskPushNotificationConfig(BaseModel):
    id: str
    PushNotificationConfig: PushNotificationConfig

# RPC Messages
# Định nghĩa cấu trúc cơ bản cho giao tiếp JSON-RPC 2.0.
class JSONRPCMessage(BaseModel):
    jsonrpc: Literal["2.0"] = "2.0" # JSON-RPC version
    id: int | str | None = Field(default_factory=lambda: uuid4().hex)

class JSONRPCRequest(JSONRPCMessage):
    method: str
    params: dict[str, Any] | None = None

class JSONRPCError(BaseModel):
    code: int
    message: str
    data: Any | None = None

class JSONRPCResponse(JSONRPCMessage):
    result: Any | None = None
    error: JSONRPCError | None = None

# Định nghĩa các yêu cầu/phản hồi cho các phương thức cụ thể. Used to send a new task to an agent
class SendTaskRequest(JSONRPCRequest):
    method: Literal["tasks/send"] = "tasks/send"
    params: TaskSendParams

class SendTaskResponse(JSONRPCResponse):
    result: Task | None = None # The task returned by the agent

# Streaming: For tasks that require extended processing time, servers can implement streaming capabilities through tasks/sendSubscribe.
# This allows clients to receive real-time updates via Server-Sent Events (SSE), including task status changes and new artifacts.
class SendTaskStreamingRequest(JSONRPCRequest):
    method: Literal["tasks/sendSubscribe"] = "tasks/sendSubscribe"
    params: TaskSendParams

class SendTaskStreamingResponse(JSONRPCResponse):
    result: TaskStatusUpdateEvent | TaskArtifactUpdateEvent | None = None

class GetTaskRequest(JSONRPCRequest):
    method: Literal["tasks/get"] = "tasks/get"
    params: TaskQueryParams


class GetTaskResponse(JSONRPCResponse):
    result: Task | None = None


class CancelTaskRequest(JSONRPCRequest):
    method: Literal["tasks/cancel",] = "tasks/cancel"
    params: TaskIdParams


class CancelTaskResponse(JSONRPCResponse):
    result: Task | None = None


class SetTaskPushNotificationRequest(JSONRPCRequest):
    method: Literal["tasks/pushNotification/set",] = "tasks/pushNotification/set"
    params: TaskPushNotificationConfig


class SetTaskPushNotificationResponse(JSONRPCResponse):
    result: TaskPushNotificationConfig | None = None


class GetTaskPushNotificationRequest(JSONRPCRequest):
    method: Literal["tasks/pushNotification/get",] = "tasks/pushNotification/get"
    params: TaskIdParams


class GetTaskPushNotificationResponse(JSONRPCResponse):
    result: TaskPushNotificationConfig | None = None


class TaskResubscriptionRequest(JSONRPCRequest):
    method: Literal["tasks/resubscribe",] = "tasks/resubscribe"
    params: TaskIdParams

# Tạo một adapter để xác thực và phân tích các yêu cầu RPC dựa trên trường method.
# Cho phép server xử lý nhiều loại yêu cầu RPC một cách thống nhất.
A2ARequest = TypeAdapter(
    Annotated[
        Union[ # các loại yêu cầu RPC.
            SendTaskRequest,
            GetTaskRequest,
            CancelTaskRequest,
            SetTaskPushNotificationRequest,
            GetTaskPushNotificationRequest,
            TaskResubscriptionRequest,
            SendTaskStreamingRequest,
        ],
        Field(discriminator="method")
    ]
)

# Error types
# Định nghĩa các lỗi cụ thể cho JSON-RPC.
# Trả về trong JSONRPCResponse.error khi có lỗi.
class JSONParseError(JSONRPCError):
    code: int = -32700
    message: str = "Invalid JSON payload"
    data: Any | None = None

class InvalidRequestError(JSONRPCError):
    code: int = -32600
    message: str = "Request payload validation error"
    data: Any | None = None


class MethodNotFoundError(JSONRPCError):
    code: int = -32601
    message: str = "Method not found"
    data: None = None


class InvalidParamsError(JSONRPCError):
    code: int = -32602
    message: str = "Invalid parameters"
    data: Any | None = None


class InternalError(JSONRPCError):
    code: int = -32603
    message: str = "Internal error"
    data: Any | None = None


class TaskNotFoundError(JSONRPCError):
    code: int = -32001
    message: str = "Task not found"
    data: None = None


class TaskNotCancelableError(JSONRPCError):
    code: int = -32002
    message: str = "Task cannot be canceled"
    data: None = None


class PushNotificationNotSupportedError(JSONRPCError):
    code: int = -32003
    message: str = "Push Notification is not supported"
    data: None = None


class UnsupportedOperationError(JSONRPCError):
    code: int = -32004
    message: str = "This operation is not supported"
    data: None = None


class ContentTypeNotSupportedError(JSONRPCError):
    code: int = -32005
    message: str = "Incompatible content types"
    data: None = None

# Agent model
class AgentProvider(BaseModel):
    organization: str
    url: str | None = None

# defines what features or protocols the agent supports.
class AgentCapabilities(BaseModel):
    streaming: bool = False # Indicates if the agent can send intermediate task results through streaming
    pushNotifications: bool = False # Indicates if the agent can push updates via HTTP push/webhooks
    stateTransitionHistory: bool = False # If enabled, the agent keeps track of the history of task state transitions

class AgentAuthentication(BaseModel):
    schemes: List[str]
    credentials: str | None = None

# This class defines metadata about a single skill that the agent offers.
# Each skill corresponds to a specific type of task the agent can perform.
class AgentSkill(BaseModel):
    id: str # Unique identifier for the skill (e.g., "get_time")
    name: str # Human-readable name for the skill (e.g., "Get Current Time")
    description: str | None = None # Optional description to help users understand what the skill does
    tags: List[str] | None = None # Optional tags to help categorize or search for the skill (e.g., ["time", "clock"])
    examples: List[str] | None = None # Optional example phrases that this skill might respond to
    inputModes: List[str] | None = None # Optional list of supported input modes (e.g., ["text", "json"])
    outputModes: List[str] | None = None # Optional list of supported output modes (e.g., ["text", "image"])

# This information can be shared with a directory service or other agents to describe what the agent does, where to reach it, and what capabilities it supports.
class AgentCard(BaseModel):
    name: str
    description: str | None = None
    url: str
    provider: AgentProvider | None = None
    version: str
    documentationUrl: str | None = None
    capabilities: AgentCapabilities #The capabilities this agent supports (uses the AgentCapabilities model above)
    authentication: AgentAuthentication | None = None
    defaultInputModes: List[str] = ["text"]
    defaultOutputModes: List[str] = ["text"]
    skills: List[AgentSkill] # # List of skills (as strings) this agent can perform

# Client errors
class A2AClientError(Exception):
    pass

class A2AClientHTTPError(A2AClientError):
    def __init__(self, status_code: int, message: str):
        self.status_code = status_code
        self.message = message
        super().__init__(f"HTTP Error {status_code}: {message}")

class A2AClientJSONError(A2AClientError):
    def __init__(self, message: str):
        self.message = message
        super().__init__(f"JSON Error: {message}")

class MissingAPIKeyError(Exception):
    pass

# 1. Khởi tạo tác vụ:
# Client gửi SendTaskRequest với TaskSendParams (chứa Message từ user).
# Server tạo Task với trạng thái SUBMITTED và trả về SendTaskResponse.
# 2. Theo dõi tác vụ:
# Client dùng GetTaskRequest để lấy thông tin Task.
# Hoặc dùng SendTaskStreamingRequest để nhận cập nhật qua TaskStatusUpdateEvent hoặc TaskArtifactUpdateEvent.
# 3. Quản lý tác vụ:
# Hủy tác vụ bằng CancelTaskRequest.
# Cấu hình thông báo đẩy bằng SetTaskPushNotificationRequest.
# 4. Xử lý lỗi:
# Server trả về JSONRPCError (ví dụ: TaskNotFoundError) nếu có lỗi.
# Client xử lý lỗi qua A2AClientError hoặc MissingAPIKeyError.
# 5. Khám phá agent:
# Client truy vấn AgentCard để biết khả năng và kỹ năng của agent.